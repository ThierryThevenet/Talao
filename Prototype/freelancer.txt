// pour prototypage only
//
//
//
//
//

pragma solidity ^0.4.0;
contract Freelancer {
 //
// descriptif d un freelancer  
    struct CommunityMember {
        address CommunityAddress;           // ref de la comunauté du freelancer  
        uint State;                      // inactif 0 actif 1
        int ContributionRating;        // represente l implication dans la communauté, attention au type uint et int
        int ContributionRatingBlock;   // pour gere la decay, on met le muneto de block last upate
        uint ClientRating1;           // 4 dernieres evaluations clients
        uint ClientRating2;
        uint ClientRating3;
        uint ClientRating4;
    }
  // Mapping that matches Drupal generated hash with Ethereum Account address.
  // key = Drupal Hash Value = Ethereum address
    mapping (bytes32 => address) _accounts;
   // 
    mapping (address => CommunityMember) public freelancerdata ;   // tableau d acces par adresse au freelance
    int BlockPerQuarter = 650000;               // 650000 block mines tous les 3 mois environ
    

   
  // If a newer version of this registry is available, force users to use it cf Drupal
    bool _registrationDisabled;

  // Event allowing listening to newly signed Accounts (?)
    event AccountCreatedEvent (address indexedfrom, bytes32 indexedhash, int error);

    function accountCreated(address from, bytes32 hash, int error) {
    AccountCreatedEvent(from, hash, error);
  }




    
// creator, initialisation
// creation en dur du freelancer Thierry sur la communauté OpenExpert Service Provider (adresse sur sur Ropsten) 
// avec rating de contribtion de 50 et les 4 dernieres evaluations 
// client a 10. La dernier cacul de cntribution avec decay réalisé au block 4400000
    function Freelancer() {
        address OpenExpert = (0xF82076776FeF59Ad28d4E1dEa91f366deCef0CA6);  // la communauté OpenExpert Serive Providr
        address Aerospace = (0xD53F199C942638BaC5E65C48B6D1555c1e226140);    // la communauté aerospace Emindhub
        address Thierry_founder = (0x3923B7c310C045Ca72e405DbDd052e968eAF7e25);
        address Thierry_freelance = (0x87B787CD17a8D68db002f806cC0A3DA323EaC25a);     
        
        freelancerdata[Thierry_founder] = CommunityMember (OpenExpert,1,0,4400000,0,0,0,0);
        freelancerdata[Thierry_freelance] = CommunityMember (Aerospace,1,50,4400000,10,10,10,10);
      
            }
//
// mise a jour de la dernieres evaluation client pour un freelance, l eval 4 est recopiée dans la 3 etc
    
    function registeraclientrating(address AddressFreelancer, uint LastRating) {
        freelancerdata[AddressFreelancer].ClientRating1=freelancerdata[AddressFreelancer].ClientRating2;
        freelancerdata[AddressFreelancer].ClientRating2=freelancerdata[AddressFreelancer].ClientRating3;       
        freelancerdata[AddressFreelancer].ClientRating3=freelancerdata[AddressFreelancer].ClientRating4;
        freelancerdata[AddressFreelancer].ClientRating4=LastRating;
       
     }
//
//  mise a jour d'une contribution d un freelancer avec prise en compte du decay de 1 point par650000 blocks
    function updatecontribution(address AddressFreelancer, int LastContribution){
        freelancerdata[AddressFreelancer].ContributionRating= freelancerdata[AddressFreelancer].ContributionRating+LastContribution; 
        freelancerdata[AddressFreelancer].ContributionRating-=  (int(block.number)-freelancerdata[AddressFreelancer].ContributionRatingBlock)/BlockPerQuarter;
        freelancerdata[AddressFreelancer].ContributionRatingBlock= int(block.number); // mise a jour de la date du dernier calcul de reputation
    }
// freelancer registration with Drupal Hash as key 
// par defaut tout est à 0
//     je suppose que l adresse de la communauté est connue a l initialisation
//
    function newfreelancer(bytes32 drupalUserHash, address AddressCommunity){
       
    if (_accounts[drupalUserHash] == msg.sender) {
      // Hash allready registered to address.
      accountCreated(msg.sender, drupalUserHash, 4);
    }
    else if (_accounts[drupalUserHash] > 0) {
      // Hash allready registered to different address.
      accountCreated(msg.sender, drupalUserHash, 3);
    }
     else if (drupalUserHash.length > 32) {
      // Hash too long
      accountCreated(msg.sender, drupalUserHash, 2);
    }
    else if (_registrationDisabled){
      // Registry is disabled because a newer version is available
      accountCreated(msg.sender, drupalUserHash, 1);
    }
    else {
      _accounts[drupalUserHash] = msg.sender;
      accountCreated(msg.sender, drupalUserHash, 0);
        freelancerdata[msg.sender].CommunityAddress = AddressCommunity; 
        freelancerdata[msg.sender].ContributionRatingBlock= int(block.number); // mise a jour de la date du dernier calcul de reputation
        freelancerdata[msg.sender].State=1;
     
        }
   ///  
    }
// pour sortir un freelancer
    function fireafreelancer(address AddressFreelancer){
        freelancerdata[AddressFreelancer].State =0;
        // on ne remet pas l index a jour....
    }
    
    
  // Validate Account for Drupal
    function validateFreelancerByHash (bytes32 drupalUserHash) constant returns (address result){
      return _accounts[drupalUserHash];
  }
    
    
//
// fonctions techniques internes DAO
//
//
//
//
    function getfreelancerdatafromaddress(address AddressFreelancer) constant returns (address, uint, int, uint){
        uint ClientRating =(freelancerdata[AddressFreelancer].ClientRating1+freelancerdata[AddressFreelancer].ClientRating2+freelancerdata[AddressFreelancer].ClientRating3+freelancerdata[AddressFreelancer].ClientRating4)/4;
        return (freelancerdata[AddressFreelancer].CommunityAddress, freelancerdata[AddressFreelancer].State, freelancerdata[AddressFreelancer].ContributionRating, ClientRating) ;
    }


    
    





// end of contract
 }
 